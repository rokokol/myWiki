---
title: Разбираемся в АЛЛОКАТОРАХ
media_link: https://www.youtube.com/watch?v=DuHoT6bmb10
author:
  - Полевой Дмитрий
created: 2025-04-29
tags:
  - y2025
  - cpp
  - учеба
  - конспекты
master: "[[C++ Hub|С++]]"
icon: LiMemoryStick
---

# Аллокаторы в C++

Аллокаторы бывают двух типов:
1. *Низкоуровневые*: `malloc`, `jemalloc`, `tcmalloc`, ...
2. *Аллокаторы в C++*: `std::allocator`

> [!tip] По умолчанию `std::vector<T>` = `std::vector<T, std::allocator<T>>`
> Аллокатор выступает как прослойка для работы с элементами; Также у любого `stl` контейнера есть конструктор, который принимает объект аллокатора — [23:51](https://www.youtube.com/watch?t=1431&v=DuHoT6bmb10)



## Создание аллокатора  [10:48](https://www.youtube.com/watch?t=648&v=DuHoT6bmb10)
Должны быть *обязательно* реализованы методы:
- `allocate` — возвращает указатель на `T` и принимает *количество элементов* (не смотря на то, что они в `size_t`, под которые нужно выделить память
- `deallocate` — принимает указатель `T*` и количество элементов, память из-под которых необходимо освободить
А так же нужно указать используемый тип: `using value_type = T;`
> [!warning] Раньше требовалось реализовать намного больше функций для того, чтобы создать свой аллокатор [17:28](https://www.youtube.com/watch?t=1048&v=DuHoT6bmb10)
> 
> `std::allocator_traits` — класс, который реализует все эти функции, если они не были реализованы в самом аллокаторе; сам `std::allocator_traits` содержит только статические методы [19:00](https://www.youtube.com/watch?t=1149&v=DuHoT6bmb10)


[20:20](https://www.youtube.com/watch?t=1284&v=DuHoT6bmb10) Если аллокатор не содержит полей, то он **stateless**; иначе **statefull**


> [!note] 2 аллокатора считаются равными, если память, выделенную одним можно безопасно освободить другим. Технически, если это один и тот же аллокатор [14:43](https://www.youtube.com/watch?t=883&v=DuHoT6bmb10)

Когда мы создаем `std::list<int>`, то передавая аллокатор для `int`, он все равно используется для создания `node`. Этот механизм называется **allocator_traits** [15:58](https://www.youtube.com/watch?t=958&v=DuHoT6bmb10)
> Работает он с помощью метафункции `rebind`, что позволяет из аллокатора одного типа создавать аллокатор другого

> При *копировании* контейнеров у аллокаторов по умолчанию вызывается метод `select_on_container_cope_construction`. По умолчанию он копирует аллокатор [26:44](https://www.youtube.com/watch?t=1604&v=DuHoT6bmb10)

> При *присваивании* контейнеров аллокатор не копируется, а остается прежний. Для разрешения используются `propagate`'ы [28:47](https://www.youtube.com/watch?t=1727&v=DuHoT6bmb10) 

## Полиморфные аллокаторы [29:45](https://www.youtube.com/watch?t=1785&v=DuHoT6bmb10)
Некруто, когда мы не можем присваивать контейнеры с разными аллокаторами, правда? Попробуем решить это при помощи полиморфизма!